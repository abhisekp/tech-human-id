// Generated by Qodo Gen

import { humanId, adverbs, adjectives, nouns, verbs } from "./index";

describe("humanId", () => {
  // Returns string with default options (one adjective, noun, verb, capitalized, no separator)
  it("should return capitalized string with one adjective, noun and verb when called with no options", () => {
    const result = humanId();

    expect(typeof result).toBe("string");

    const parts = result.split(/(?=[A-Z])/);

    expect(parts).toHaveLength(3);

    expect(adjectives).toContain(parts[0].toLowerCase());

    expect(nouns).toContain(parts[1].toLowerCase());

    expect(verbs).toContain(parts[2].toLowerCase());

    expect(result).toMatch(/^[A-Z][a-z]+[A-Z][a-z]+[A-Z][a-z]+$/);
  });

  // Handles empty string separator
  it("should return parts joined with empty separator when empty string separator provided", () => {
    const result = humanId("");

    expect(typeof result).toBe("string");

    const parts = result.split(/(?=[A-Z])/);

    expect(parts).toHaveLength(3);

    expect(result).not.toContain(" ");

    expect(result).not.toContain("-");

    expect(result).not.toContain("_");
  });

  // Returns string with custom separator when string option provided
  it("should return string with custom separator when string option is provided", () => {
    const separator = "-";
    const result = humanId(separator);

    expect(typeof result).toBe("string");

    const parts = result.split(separator);

    expect(parts).toHaveLength(3);

    expect(adjectives).toContain(parts[0].toLowerCase());

    expect(nouns).toContain(parts[1].toLowerCase());

    expect(verbs).toContain(parts[2].toLowerCase());

    expect(result).toMatch(/^[A-Z][a-z]+-[A-Z][a-z]+-[A-Z][a-z]+$/);
  });

  // Handles special characters as separator
  it("should return a string with special character as separator when separator is a special character", () => {
    const separator = "@";
    const result = humanId({ separator });

    expect(typeof result).toBe("string");

    const parts = result.split(separator);

    expect(parts).toHaveLength(3);

    expect(adjectives).toContain(parts[0].toLowerCase());

    expect(nouns).toContain(parts[1].toLowerCase());

    expect(verbs).toContain(parts[2].toLowerCase());

    expect(result).toMatch(/^[A-Z][a-z]+@[A-Z][a-z]+@[A-Z][a-z]+$/);
  });

  // Returns string with multiple adjectives when adjectiveCount > 1
  it("should return string with multiple adjectives when adjectiveCount is greater than 1", () => {
    const adjectiveCount = 3;
    const result = humanId({ adjectiveCount });

    expect(typeof result).toBe("string");

    const parts = result.split(/(?=[A-Z])/);

    expect(parts).toHaveLength(adjectiveCount + 2);

    for (let i = 0; i < adjectiveCount; i++) {
      expect(adjectives).toContain(parts[i].toLowerCase());
    }

    expect(nouns).toContain(parts[adjectiveCount].toLowerCase());

    expect(verbs).toContain(parts[adjectiveCount + 1].toLowerCase());

    expect(result).toMatch(new RegExp(`^([A-Z][a-z]+){${adjectiveCount}}[A-Z][a-z]+[A-Z][a-z]+$`));
  });

  // Returns string with adverb when addAdverb is true
  it("should return string with adverb when addAdverb is true", () => {
    const result = humanId({ addAdverb: true });

    expect(typeof result).toBe("string");

    const parts = result.split(/(?=[A-Z])/);

    expect(parts).toHaveLength(4);

    expect(adjectives).toContain(parts[0].toLowerCase());

    expect(nouns).toContain(parts[1].toLowerCase());

    expect(verbs).toContain(parts[2].toLowerCase());

    expect(adverbs).toContain(parts[3].toLowerCase());

    expect(result).toMatch(/^[A-Z][a-z]+[A-Z][a-z]+[A-Z][a-z]+[A-Z][a-z]+$/);
  });

  // Handles null/undefined options parameter
  it("should return capitalized string with one adjective, noun, and verb when options parameter is null", () => {
    const result = humanId();

    expect(typeof result).toBe("string");

    const parts = result.split(/(?=[A-Z])/);

    expect(parts).toHaveLength(3);

    expect(adjectives).toContain(parts[0].toLowerCase());

    expect(nouns).toContain(parts[1].toLowerCase());

    expect(verbs).toContain(parts[2].toLowerCase());

    expect(result).toMatch(/^[A-Z][a-z]+[A-Z][a-z]+[A-Z][a-z]+$/);
  });

  // Generates different random values on each call
  it("should generate different values on consecutive calls", () => {
    const result1 = humanId();
    const result2 = humanId();

    expect(result1).not.toBe(result2);
  });

  // Returns string with all options combined (separator, capitalize, adjectiveCount, addAdverb)
  it("should return a string with specified separator, capitalization, multiple adjectives, and an adverb", () => {
    const options = {
      separator: "-",
      capitalize: true,
      adjectiveCount: 2,
      addAdverb: true,
    };

    const result = humanId(options);

    expect(typeof result).toBe("string");

    const parts = result.split("-");

    expect(parts).toHaveLength(5);

    expect(adjectives).toContain(parts[0].toLowerCase());
    expect(adjectives).toContain(parts[1].toLowerCase());
    expect(nouns).toContain(parts[2].toLowerCase());
    expect(verbs).toContain(parts[3].toLowerCase());
    expect(adverbs).toContain(parts[4].toLowerCase());

    expect(result).toMatch(/^[A-Z][a-z]+-[A-Z][a-z]+-[A-Z][a-z]+-[A-Z][a-z]+-[A-Z][a-z]+$/);
  });

  // Handles adjectiveCount of 0
  it("should return capitalized string with only noun and verb when adjectiveCount is 0", () => {
    const result = humanId({ adjectiveCount: 0 });

    expect(typeof result).toBe("string");

    const parts = result.split(/(?=[A-Z])/);

    expect(parts).toHaveLength(2);

    expect(nouns).toContain(parts[0].toLowerCase());

    expect(verbs).toContain(parts[1].toLowerCase());

    expect(result).toMatch(/^[A-Z][a-z]+[A-Z][a-z]+$/);
  });
});
